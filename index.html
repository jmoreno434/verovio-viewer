<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>MusicXML/MXL → SVG + Reproductor (tempo, bucle, mezcla)</title>

  <!-- Verovio (WASM) -->
  <script src="https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js" defer></script>

  <!-- Tone.js -->
  <script src="https://unpkg.com/tone@15.1.22/build/Tone.js"></script>

  <!-- soundfont-player (instrumentos GM sin 404) -->
  <script src="https://unpkg.com/soundfont-player@0.8.1/dist/soundfont-player.js"></script>

  <link rel="icon" href="data:," />
  <style>
    body { font-family: system-ui, sans-serif; margin: 1rem; }
    .row { display:flex; gap:1rem; flex-wrap:wrap; align-items:center; margin-bottom:.6rem; }
    button, input, select { padding:.4rem .6rem; }
    #notation { border:1px solid #ddd; padding:1rem; min-height:260px; }

    /* Nota en reproducción */
    g.note.playing, g.note.playing * { fill:#d00 !important; stroke:#d00 !important; }

    /* Compás actual */
    g.measure.current-measure, g.measure.current-measure * {
      stroke:#e67e22 !important; stroke-width:1.5 !important;
    }

    fieldset { border:1px solid #e0e0e0; padding:.6rem .8rem; border-radius:.4rem; }
    legend { font-weight:600; }
  </style>
</head>
<body>
  <h1>MusicXML/MXL → SVG + Player</h1>

  <!-- Carga y render -->
  <div class="row">
    <input id="fileInput" type="file" accept=".xml,.musicxml,.mxl" />
    <button id="renderBtn" disabled>Renderizar</button>
    <span id="info"></span>
  </div>

  <!-- Paginación & escala -->
  <div class="row">
    <button id="prevBtn" disabled>← Anterior</button>
    <span>Página <span id="pageNow">1</span>/<span id="pageMax">1</span></span>
    <button id="nextBtn" disabled>Siguiente →</button>
    <label>Escala (%) <input id="scaleInput" type="number" min="30" max="200" step="5" value="60"></label>
    <button id="applyScale" disabled>Aplicar</button>
  </div>

  <!-- Instrumento -->
  <div class="row">
    <label>Instrumento
      <select id="instrumentSelect">
        <!-- nombres GM que reconoce soundfont-player -->
        <option value="acoustic_grand_piano" selected>Piano</option>
        <option value="violin">Violín</option>
        <option value="cello">Cello</option>
        <option value="flute">Flauta</option>
        <option value="tenor_sax">Saxo tenor</option>
        <option value="trumpet">Trompeta</option>
        <option value="trombone">Trombón</option>
        <option value="acoustic_guitar_nylon">Guitarra clásica</option>
        <option value="electric_guitar_clean">Guitarra eléctrica</option>
        <option value="choir_aahs">Coro (Aahs)</option>
      </select>
    </label>
    <button id="loadInstBtn" disabled>Cargar instrumento</button>
    <span id="instInfo"></span>
  </div>

  <!-- Reproducción -->
  <fieldset>
    <legend>Reproducción</legend>
    <div class="row">
      <button id="playBtn" disabled>▶ Reproducir</button>
      <button id="stopBtn" disabled>■ Detener</button>

      <label>Tempo (♩=)
        <input id="tempoRange" type="range" min="40" max="200" step="1" value="120">
        <span id="tempoVal">120</span>
      </label>

      <label>Loop compases:
        <input id="loopStart" type="number" min="1" value="1" style="width:4rem"> –
        <input id="loopEnd" type="number" min="1" value="4" style="width:4rem">
      </label>
      <button id="applyLoop" disabled>Aplicar bucle</button>
      <button id="clearLoop" disabled>Quitar bucle</button>

      <span id="meterNow"></span>
    </div>
  </fieldset>

  <!-- Mezcla por voces (staves) -->
  <fieldset>
    <legend>Mezcla por voces</legend>
    <div id="mixer" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:.5rem;"></div>
  </fieldset>

  <!-- Partitura -->
  <div id="notation"></div>

  <script>
  (() => {
    const $ = id => document.getElementById(id);

    let toolkit, dataBuffer, isZip=false;
    let currentPage=1, totalPages=1;
    let timemap=[], measureStarts=[], baseTempo=120, tempoNow=120;

    // Instrumento (soundfont-player)
    let sf = null; // instancia de instrumento soundfont-player
    const ac = () => Tone.getContext().rawContext; // AudioContext de Tone.js

    // Mezcla por staff
    let staffGain = {};      // [0..1]
    let staffMute = {};      // boolean
    let staffSolo = null;    // número de staff o null

    // ===== Inicializar Verovio =====
    document.addEventListener('DOMContentLoaded', () => {
      verovio.module.onRuntimeInitialized = () => {
        toolkit = new verovio.toolkit();
        ['renderBtn','applyScale','loadInstBtn','playBtn','stopBtn','applyLoop','clearLoop']
          .forEach(id => $(id).disabled = false);
      };
    });

    // ===== Entrada de archivo =====
    $('fileInput').addEventListener('change', e => {
      const f = e.target.files[0]; if(!f) return;
      isZip = /\.mxl$/i.test(f.name);
      $('info').textContent = f.name;
      const r = new FileReader();
      r.onload = () => dataBuffer = r.result;
      isZip ? r.readAsArrayBuffer(f) : r.readAsText(f);
    });

    // ===== Render + Timemap =====
    function applyOptions() {
      toolkit.setOptions({ pageWidth:2000, pageHeight:2600, scale:+$('scaleInput').value });
    }

    $('renderBtn').onclick = () => {
      if(!dataBuffer) return;
      applyOptions();
      if(isZip) toolkit.loadZipDataBuffer(new Uint8Array(dataBuffer), dataBuffer.byteLength);
      else      toolkit.loadData(dataBuffer);

      totalPages = toolkit.getPageCount();
      currentPage = 1;
      $('pageMax').textContent = totalPages;
      $('notation').innerHTML = toolkit.renderToSVG(currentPage);
      $('pageNow').textContent = currentPage;

      // Timemap (puede venir como objeto o string; ser tolerantes)
      let tmRaw = toolkit.renderToTimemap({ includeMeasures:true });
      timemap = (typeof tmRaw === 'string') ? JSON.parse(tmRaw) : tmRaw; // JS devuelve objeto. :contentReference[oaicite:5]{index=5}

      // Tempo base si la timemap lo indica
      const tEvt = timemap.find(e => typeof e.tempo !== 'undefined');
      baseTempo = tEvt ? Number(tEvt.tempo) : 120;
      tempoNow = baseTempo;
      $('tempoRange').value = tempoNow;
      $('tempoVal').textContent = tempoNow;

      // Inicios de compás (por qstamp entero creciente)
      measureStarts = [];
      let lastQ=-1, idx=1;
      for (const ev of timemap) {
        if (Number.isFinite(ev.qstamp)) {
          const isBar = Math.abs(ev.qstamp - Math.round(ev.qstamp)) < 1e-6 && ev.qstamp > lastQ;
          if (isBar) { measureStarts[idx++] = (ev.tstamp||0)/1000; lastQ = ev.qstamp; }
        }
      }

      // Necesario antes de getMIDIValuesForElement()
      toolkit.renderToMIDI(); // prepara datos MIDI internos. :contentReference[oaicite:6]{index=6}
    };

    $('prevBtn').onclick = () => { if(currentPage>1){ currentPage--; $('notation').innerHTML = toolkit.renderToSVG(currentPage); $('pageNow').textContent=currentPage; } };
    $('nextBtn').onclick = () => { if(currentPage<totalPages){ currentPage++; $('notation').innerHTML = toolkit.renderToSVG(currentPage); $('pageNow').textContent=currentPage; } };
    $('applyScale').onclick = () => { applyOptions(); $('notation').innerHTML = toolkit.renderToSVG(currentPage); };

    // ===== Cargar instrumento (soundfont-player) =====
    $('loadInstBtn').onclick = async () => {
      $('instInfo').textContent = 'Cargando…';
      try {
        sf = await Soundfont.instrument(ac(), $('instrumentSelect').value);
        $('instInfo').textContent = 'Instrumento listo';
      } catch (e) {
        console.error(e);
        $('instInfo').textContent = 'Error cargando instrumento';
      }
    };

    // ===== UI mezcla por staff =====
    function buildMixer(staves) {
      const mix = $('mixer'); mix.innerHTML = '';
      const unique = [...new Set(staves)].sort((a,b)=>a-b);
      const list = unique.length ? unique : [1,2,3,4];
      for (const s of list) {
        if (!(s in staffGain)) staffGain[s] = 1.0;
        const d = document.createElement('div');
        d.style.border='1px solid #eee'; d.style.padding='.5rem'; d.style.borderRadius='.4rem';
        d.innerHTML = `
          <strong>Staff ${s}</strong><br>
          Vol <input type="range" min="0" max="1" step="0.01" value="${staffGain[s]}" data-st="${s}" class="vol"><br>
          <button class="solo" data-st="${s}">${staffSolo===s?'Unsolo':'Solo'}</button>
          <button class="mute" data-st="${s}">${staffMute[s]?'Unmute':'Mute'}</button>
        `;
        mix.appendChild(d);
      }
      mix.querySelectorAll('.vol').forEach(r => r.oninput = e => {
        const st = +e.target.dataset.st; staffGain[st] = +e.target.value;
      });
      mix.querySelectorAll('.mute').forEach(b => b.onclick = e => {
        const st = +e.target.dataset.st; staffMute[st] = !staffMute[st]; buildMixer(list);
      });
      mix.querySelectorAll('.solo').forEach(b => b.onclick = e => {
        const st = +e.target.dataset.st; staffSolo = (staffSolo===st?null:st); buildMixer(list);
      });
    }

    function clearVisual() {
      document.querySelectorAll('g.note.playing').forEach(n => n.classList.remove('playing'));
      document.querySelectorAll('g.measure.current-measure').forEach(m => m.classList.remove('current-measure'));
    }

    // ===== Programación audio + seguimiento =====
    function scheduleAll() {
      // Reset transport
      Tone.Transport.stop(); Tone.Transport.cancel(0); Tone.Transport.position = 0;
      clearVisual();

      // Descubrir staves y cachear info por id
      const cache = new Map();
      const stavesFound = new Set();
      function infoFor(id) {
        if (cache.has(id)) return cache.get(id);
        let midi = 60, staff = 1;
        try {
          const raw = toolkit.getMIDIValuesForElement(id);
          const mj = (typeof raw === 'string') ? JSON.parse(raw) : raw; // tolerante
          if (Number.isFinite(mj?.midi)) midi = mj.midi;
        } catch {}
        try {
          const a = toolkit.getElementAttr(id);
          const aj = (typeof a === 'string') ? JSON.parse(a) : a;
          if (Number.isFinite(+aj?.staff)) staff = +aj.staff;
        } catch {}
        stavesFound.add(staff);
        const out = { midi, staff }; cache.set(id,out); return out;
      }

      buildMixer([...stavesFound]);

      // Seguimiento visual (polling ligero). No se reprograman eventos dentro del callback.
      Tone.Transport.scheduleRepeat((time) => {
        const factor = baseTempo / tempoNow;
        const realSec = Tone.Transport.seconds;
        const scoreMs = realSec * 1000 * factor;

        let els = toolkit.getElementsAtTime(Math.floor(scoreMs));
        if (typeof els === 'string') els = JSON.parse(els); // por compatibilidad. :contentReference[oaicite:7]{index=7}
        if (!els || !els.page) return;

        if (els.page !== currentPage) {
          currentPage = els.page;
          $('notation').innerHTML = toolkit.renderToSVG(currentPage);
          $('pageNow').textContent = currentPage;
        }

        clearVisual();
        (els.notes||[]).forEach(id => {
          const el = document.getElementById(id);
          if (el) el.classList.add('playing');
        });

        // Compás actual
        let cm = 1, sec = scoreMs / 1000;
        for (let i=1; i<measureStarts.length; i++) {
          if (sec >= measureStarts[i]) cm = i; else break;
        }
        $('meterNow').textContent = `Compás: ${cm}`;
        const meas = document.querySelector(`#notation g.measure[id*="${cm}"]`);
        if (meas) meas.classList.add('current-measure');
      }, 0.05); // 50 ms. :contentReference[oaicite:8]{index=8}

      // Disparo de notas
      const ctx = ac();
      for (const ev of timemap) {
        if (!ev.on || !ev.on.length) continue;
        const when = (ev.tstamp||0)/1000 * (baseTempo/tempoNow); // segundos relativos al Transport
        Tone.Transport.schedule((time) => {
          // 'time' es tiempo absoluto del AudioContext. :contentReference[oaicite:9]{index=9}
          const offset = Math.max(0, time - ctx.currentTime); // soundfont-player usa offset relativo
          for (const id of ev.on) {
            const { midi, staff } = infoFor(id);
            let vel = staffGain[staff] ?? 1;
            if (staffSolo !== null && staff !== staffSolo) vel *= 0.2;
            if (staffMute[staff]) vel = 0;
            if (vel <= 0) continue;

            const note = Tone.Frequency(midi, 'midi').toNote();
            if (sf) {
              // Duración aproximada si no hay off inmediato: 0.5s; se mejora leyendo ev.off si quieres
              sf.play(note, offset, { duration: 0.5, gain: vel }); // API soundfont-player. :contentReference[oaicite:10]{index=10}
            } else {
              // Fallback: síntesis simple
              const synth = new Tone.Synth().toDestination();
              synth.triggerAttackRelease(note, 0.5, time, vel);
            }
          }
        }, when);
      }
    }

    // ===== Play / Stop =====
    $('playBtn').onclick = async () => {
      if (!dataBuffer) return;
      // Autoplay policy: iniciar AudioContext tras gesto del usuario
      await Tone.start(); // recomendado por Tone.js. :contentReference[oaicite:11]{index=11}

      tempoNow = +$('tempoRange').value || baseTempo;
      $('tempoVal').textContent = tempoNow;

      scheduleAll();
      Tone.Transport.start();
    };

    $('stopBtn').onclick = () => {
      Tone.Transport.stop(); Tone.Transport.cancel(0); Tone.Transport.position = 0;
      clearVisual();
    };

    // ===== Tempo =====
    $('tempoRange').oninput = (e) => {
      $('tempoVal').textContent = e.target.value;
      if (Tone.Transport.state === 'started') {
        tempoNow = +e.target.value;
        scheduleAll();
        Tone.Transport.start();
      }
    };

    // ===== Loop por compases =====
    const secAtBar = (n) => (measureStarts[n] ?? 0) * (baseTempo/tempoNow);
    $('applyLoop').onclick = () => {
      const a = Math.max(1, +$('loopStart').value);
      const b = Math.max(a, +$('loopEnd').value);
      Tone.Transport.setLoopPoints(secAtBar(a), secAtBar(b));
      Tone.Transport.loop = true; // API Transport. :contentReference[oaicite:12]{index=12}
    };
    $('clearLoop').onclick = () => { Tone.Transport.loop = false; Tone.Transport.setLoopPoints(0,0); };

  })();
  </script>
</body>
</html>

